/* Net ACM_signals - IOPT */
/* Automatic code generated by IOPT2C XSLT transformation. */
/* Please fill the necessary code to perform hardware IO. */


#include <stdlib.h>
#include "net_types.h"

#include "sensors.h"

struct UltrasonicData {
    int front;
    int back;
    int left;
    int right;
};


#ifdef ARDUINO
#include <Arduino.h>
#define ANALOG_IN_MAX  1023
#define ANALOG_OUT_MAX 255
#else
#define INPUT    0
#define OUTPUT   1
#define ANALOG_IN_MAX  1023
#define ANALOG_OUT_MAX 1023
extern void pinMode( int, int );
extern int  digitalRead( int );
extern void digitalWrite( int, int );
extern int  analogRead( int );
extern void analogWrite( int, int );
#endif


// Remote IcE/Debug forced values:
#ifdef HTTP_SERVER
iopt_param_info *input_fv = NULL, *output_fv = NULL;
#endif


/* Executed just once, before net execution starts: */
void ACM_signals_InitializeIO()
{
    pinMode( 21, INPUT ); /* inChg */
    pinMode( 5, OUTPUT ); /* ForwardQ */
    pinMode( 6, OUTPUT ); /* ReverseQ */
    pinMode( 13, OUTPUT ); /* RightQ */
    pinMode( 19, OUTPUT ); /* LeftQ */
    pinMode( 26, OUTPUT ); /* Horn */
}



/* Read all hardware input signals and fill data-structure */
void ACM_signals_GetInputSignals(
            ACM_signals_InputSignals* inputs,
            ACM_signals_InputSignalEvents* events )
{
    inputs->inChg = digitalRead( 21 );

    struct UltrasonicData d = ultrasonic_read_all();
    inputs->front_sensor_dist = d.front;
    inputs->back_sensor_dist = d.back;
    inputs->left_sensor_dist = d.left;
    inputs->right_sensor_dist = d.right;
    inputs->dist_min = 30;

    int pitch, roll;
    if (imu_read_pitch_roll(&pitch, &roll) == 0) {
        inputs->pitch = pitch;
    }
#ifdef HTTP_SERVER
    if( input_fv != NULL ) force_ACM_signals_Inputs( input_fv, inputs );
#endif
}


/* Write all output values to physical hardware outputs */
void ACM_signals_PutOutputSignals(
            ACM_signals_PlaceOutputSignals* place_out,
            ACM_signals_EventOutputSignals* event_out,
            ACM_signals_OutputSignalEvents* events )
{
#ifdef HTTP_SERVER
    if( output_fv != NULL )
        force_ACM_signals_Outputs( output_fv, place_out, event_out );
#endif
    digitalWrite( 5, place_out->ForwardQ );
    digitalWrite( 6, place_out->ReverseQ );
    digitalWrite( 13, place_out->RightQ );
    digitalWrite( 19, place_out->LeftQ );
    digitalWrite( 26, place_out->Horn );
}


/* Delay between loop iterations to save CPU and power consumption */
void ACM_signals_LoopDelay()
{
}

/* Must return 1 to finish net execution */
int ACM_signals_FinishExecution( ACM_signals_NetMarking* marking )
{
    return 0;
}



